/* eslint-disable no-restricted-globals */
import { clientsClaim } from 'workbox-core';
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst } from 'workbox-strategies';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
const manifest = self.__WB_MANIFEST;
precacheAndRoute(manifest);

// Cache all images
registerRoute(
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'), // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new CacheFirst()
);

// React to messages
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Share target handler
const shareTargetHandler = async ({event}) => {
  console.log('Handling share event');

  const formData = await event.request.formData();
  const mediaFiles = formData.getAll('media');
  const cache = await caches.open('media');

  for (const mediaFile of mediaFiles) {
    // TODO: Instead of bailing, come up with a
    // default name for each possible MIME type.
    if (!mediaFile.name) {
      if (broadcastChannel) {
        broadcastChannel.postMessage('Sorry! No name found on incoming media.');
      }
      continue;
    }

    const cacheKey = new URL(`/_media/${Date.now()}-${mediaFile.name}`, self.location).href;
    await cache.put(
      cacheKey,
      new Response(mediaFile, {
        headers: {
          'content-length': mediaFile.size,
          'content-type': mediaFile.type,
        },
      })
    );

    console.log(`Put "${mediaFile.name} into cache at ${cacheKey}"`);
  }

  // Redirect to the page
  return Response.redirect('/#share', 303);
};
registerRoute(
  '/_share',
  shareTargetHandler,
  'POST'
);